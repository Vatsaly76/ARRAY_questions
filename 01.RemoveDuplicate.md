# ğŸ¯ Problem Statement

You are given a sorted array (in non-decreasing order) and you need to:

- Remove duplicates in-place (without using extra space).
- Return the length of the modified array that contains only unique elements.
- The elements beyond the modified length donâ€™t matter.

## ğŸ§  Goal/Output:

âœ… Modify the array such that:

- All unique elements are in the left part of the array.
- Return the count (k) of unique elements.

## ğŸ“ Example:

```javascript
Input: arr = [1, 1, 2, 2, 2, 3, 3]
Output: [1, 2, 3]
Return: 3

## ğŸ§ Step-by-Step Intuition
1ï¸âƒ£ Identify Key Observations:
The array is already sorted.

Duplicates will appear next to each other.

To remove duplicates, we just need to move unique elements to the left of the array.

2ï¸âƒ£ Understand the Two-Pointer Approach:
âœ… Pointer i: Keeps track of the position of the last unique element. âœ… Pointer j: Iterates through the array to find new unique elements.

ğŸ’¡ Idea:
Start with i = 0 (first unique element).

Traverse the array using j starting from j = 1.

Whenever arr[i] !== arr[j], it means we found a new unique element.

Move i one step ahead.

Place the new unique element at position i.

Continue this process until the end.

ğŸ”¥ Visualizing the Process:
Consider the array:
ini
arr = [1, 1, 2, 2, 2, 3, 3]
ğŸ‘‰ Initial State:

i = 0, j = 1
arr[i] = 1, arr[j] = 1 (duplicate, ignore)
ğŸ‘‰ Move j forward:

i = 0, j = 2
arr[i] = 1, arr[j] = 2 (new element found!)
=> Move `i` to 1
=> arr[1] = 2
ğŸ‘‰ Move j forward:

i = 1, j = 3
arr[i] = 2, arr[j] = 2 (duplicate, ignore)
ğŸ‘‰ Move j forward:

i = 1, j = 5
arr[i] = 2, arr[j] = 3 (new element found!)
=> Move `i` to 2
=> arr[2] = 3
ğŸ‘‰ End of array reached:

i + 1 = 3 (Length of the modified array)
Modified array: [1, 2, 3]
ğŸ“ Final Code (with Explanation):
javascript
function removeDuplicates(arr) {
  let i = 0; // Initial position for unique elements

  for (let j = 1; j < arr.length; j++) {
    // If a new unique element is found
    if (arr[i] !== arr[j]) {
      i++; // Move `i` to next position
      arr[i] = arr[j]; // Store the new unique element
    }
  }

  // `i + 1` gives the length of the modified array
  return i + 1;
}
ğŸ§ª Test Cases:
javascript
const arr1 = [1, 1, 2, 2, 2, 3, 3];
console.log(removeDuplicates(arr1)); // Output: 3 (Modified array: [1, 2, 3])

const arr2 = [1, 1, 1, 1, 1];
console.log(removeDuplicates(arr2)); // Output: 1 (Modified array: [1])

const arr3 = [1, 2, 3, 4, 5];
console.log(removeDuplicates(arr3)); // Output: 5 (No duplicates, same array)

const arr4 = [];
console.log(removeDuplicates(arr4)); // Output: 0 (Empty array)

const arr5 = [5, 5, 5, 5, 5, 6, 6, 7, 7, 8];
console.log(removeDuplicates(arr5)); // Output: 4 (Modified array: [5, 6, 7, 8])
âš¡ï¸ Time and Space Complexity:
ğŸ•’ Time Complexity: O(n) Single pass through the array.

ğŸ’¾ Space Complexity: O(1) Modifying the array in place without extra space.

ğŸ¤” Why This Approach Works:
Since the array is sorted, all duplicates are adjacent.

We just need to move the unique elements to the left, which makes this a perfect case for the two-pointer approach.

ğŸ§  Key Takeaways:
âœ… Youâ€™re modifying the array in place using two pointers. âœ… Moving elements only when a unique element is found optimizes the process. âœ… The final array only contains unique elements up to index i.